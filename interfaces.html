<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interfaces - POO</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        pre[class*="language-"] {
            padding: 1.2em !important;
            margin: .5em 0;
            overflow: auto;
            border-radius: 0.5rem;
        }
        h3 {
            margin-top: 1rem;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">

        <header class="text-center my-8">
            <h1 class="text-4xl md:text-5xl font-extrabold text-gray-900">Interfaces em POO</h1>
            <p class="text-xl text-gray-600 mt-2">Definindo Contratos para Classes</p>
        </header>

        <main class="bg-white rounded-xl shadow-lg p-6 md:p-10 space-y-12">
            
            <section>
                <h2 class="text-3xl font-bold text-indigo-600 mb-4">O que é uma Interface?</h2>
                <div class="text-lg text-gray-700 leading-relaxed space-y-4">
                    <p>
                        Em Programação Orientada a Objetos, uma <strong>interface</strong> é um "contrato" 100% abstrato que uma classe pode se comprometer a seguir. Ela funciona como um molde que define <em>quais</em> métodos uma classe <strong>deve</strong> implementar, sem se preocupar com <em>como</em> essa implementação será feita. A interface apenas lista as assinaturas dos métodos (nome, parâmetros e tipo de retorno).
                    </p>
                    <p>
                        Pense nela como as regras de uma forma literária, como um soneto. A "interface" de um soneto exige 14 versos e um esquema de rimas específico. Como você, escritora, preenche esses versos é a sua implementação, mas a estrutura é garantida pela "interface". Qualquer poema que implemente essa interface é, inequivocamente, um soneto.
                    </p>
                    <p class="pt-2 font-semibold text-gray-800">
                        Nesta página, veremos três níveis de exemplos para construir seu entendimento de forma gradual.
                    </p>
                </div>
            </section>

            <!-- Exemplo 1: Simples -->
            <section>
                <h2 class="text-3xl font-bold text-indigo-600 mb-4 border-t-2 border-indigo-100 pt-8">Exemplo 1: O Contrato Básico</h2>
                <p class="text-lg text-gray-700 mb-4 leading-relaxed">
                    No nível mais fundamental, uma interface garante que classes diferentes tenham um método em comum. Imagine que queremos que vários tipos de objetos possam ser "identificados" por um texto. Criamos uma interface `Identificavel`.
                </p>
                <div class="bg-gray-800 rounded-lg overflow-hidden">
<pre><code class="language-php">
&lt;?php

// O contrato: qualquer classe "Identificavel" DEVE ter o método getIdentificador.
interface Identificavel {
    public function getIdentificador(): string;
}

// Produto implementa o contrato.
class Produto implements Identificavel {
    public function __construct(private string $sku, private string $nome) {}

    public function getIdentificador(): string {
        return "Produto SKU: {$this->sku}";
    }
}

// Usuário também implementa o mesmo contrato, mas de forma diferente.
class Usuario implements Identificavel {
    public function __construct(private int $id, private string $email) {}

    public function getIdentificador(): string {
        return "Usuário #{$this->id} ({$this->email})";
    }
}

$produto = new Produto("TSH-01-RED", "Camiseta Vermelha");
$usuario = new Usuario(101, "aurora@email.com");

echo $produto->getIdentificador(); // Saída: Produto SKU: TSH-01-RED
echo $usuario->getIdentificador(); // Saída: Usuário #101 (aurora@email.com)

</code></pre>
                </div>
                <h3 class="text-xl font-bold text-gray-800 mt-4">Análise do Exemplo 1:</h3>
                <p class="text-lg text-gray-700 leading-relaxed">O objetivo aqui é a <strong>consistência</strong>. Mesmo que `Produto` e `Usuario` não tenham nenhuma relação, garantimos que ambos respondem ao método `getIdentificador()`. Isso evita erros e torna o código mais previsível.</p>
            </section>
            
            <!-- Exemplo 2: Polimorfismo -->
            <section>
                <h2 class="text-3xl font-bold text-indigo-600 mb-4 border-t-2 border-indigo-100 pt-8">Exemplo 2: Polimorfismo em Ação</h2>
                <p class="text-lg text-gray-700 mb-4 leading-relaxed">
                    Agora vamos usar o contrato para criar código flexível. Uma função pode declarar que aceita qualquer objeto que siga o contrato, sem se importar com a classe específica. Isso é polimorfismo. Usaremos a interface `Publicavel`.
                </p>
                <div class="bg-gray-800 rounded-lg overflow-hidden">
<pre><code class="language-php">
&lt;?php

interface Publicavel {
    public function exibirEmHTML(): string;
}

class Artigo implements Publicavel {
    public function __construct(private string $titulo, private string $conteudo) {}

    public function exibirEmHTML(): string {
        return "&lt;article&gt;&lt;h1&gt;{$this->titulo}&lt;/h1&gt;&lt;p&gt;{$this->conteudo}&lt;/p&gt;&lt;/article&gt;";
    }
}

class Video implements Publicavel {
    public function __construct(private string $titulo, private string $url) {}

    public function exibirEmHTML(): string {
        return "&lt;div&gt;&lt;h3&gt;{$this->titulo}&lt;/h3&gt;&lt;iframe src='{$this->url}'&gt;&lt;/iframe&gt;&lt;/div&gt;";
    }
}

// Esta função aceita QUALQUER objeto que implemente "Publicavel".
function renderizarConteudo(Publicavel $item) {
    echo $item->exibirEmHTML();
}

renderizarConteudo(new Artigo("POO com PHP", "..."));
renderizarConteudo(new Video("Tutorial de Interface", "..."));

</code></pre>
                </div>
                <h3 class="text-xl font-bold text-gray-800 mt-4">Análise do Exemplo 2:</h3>
                <p class="text-lg text-gray-700 leading-relaxed">O poder aqui está na função `renderizarConteudo`. Ela é <strong>desacoplada</strong> das classes concretas (`Artigo`, `Video`). Podemos criar uma nova classe `Podcast implements Publicavel` amanhã e a função `renderizarConteudo` funcionará com ela sem precisar de nenhuma alteração. Isso é código extensível.</p>
            </section>

            <!-- Exemplo 3: Múltiplos Contratos -->
            <section>
                <h2 class="text-3xl font-bold text-indigo-600 mb-4 border-t-2 border-indigo-100 pt-8">Exemplo 3: Múltiplos Contratos</h2>
                <p class="text-lg text-gray-700 mb-4 leading-relaxed">
                    Uma classe só pode herdar de uma outra classe (herança simples), mas pode implementar <strong>múltiplas interfaces</strong>. Isso permite que um objeto "assuma" vários comportamentos diferentes.
                </p>
                <div class="bg-gray-800 rounded-lg overflow-hidden">
<pre><code class="language-php">
&lt;?php

// Contrato para objetos que podem ser salvos em log.
interface Logavel {
    public function paraTextoLog(): string;
}

// Contrato para objetos que podem ser convertidos para JSON (para uma API, por exemplo).
interface JsonSerializavel {
    public function paraJSON(): string;
}

// Esta classe assina AMBOS os contratos.
class Transacao implements Logavel, JsonSerializavel {
    public function __construct(
        private string $id, 
        private float $valor, 
        private DateTime $data
    ) {}

    // Implementação obrigatória de Logavel
    public function paraTextoLog(): string {
        return sprintf(
            "[%s] Transação %s - Valor: R$ %.2f",
            $this->data->format('Y-m-d H:i:s'),
            $this->id,
            $this->valor
        );
    }

    // Implementação obrigatória de JsonSerializavel
    public function paraJSON(): string {
        return json_encode([
            'id' => $this->id,
            'valor' => $this->valor,
            'data' => $this->data->format(DateTime::ATOM)
        ]);
    }
}

$transacao = new Transacao('tx_123', 150.75, new DateTime());

// Podemos usar o objeto em diferentes contextos, graças às interfaces:
echo "LOG: " . $transacao->paraTextoLog();
echo "\nAPI: " . $transacao->paraJSON();
</code></pre>
                </div>
                <h3 class="text-xl font-bold text-gray-800 mt-4">Análise do Exemplo 3:</h3>
                <p class="text-lg text-gray-700 leading-relaxed">A classe `Transacao` agora é extremamente versátil. Um módulo de auditoria pode exigir objetos `Logavel` para registrar eventos, enquanto um módulo de API pode exigir objetos `JsonSerializavel` para expor dados. A nossa classe se encaixa nos dois cenários, "herdando" comportamentos de múltiplas fontes sem usar herança tradicional.</p>
            </section>
            
            <footer class="text-center mt-12 border-t-2 border-indigo-100 pt-8">
                <a href="index.html" class="inline-block bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-indigo-700 transition-colors duration-300">
                    &larr; Voltar ao Índice
                </a>
            </footer>

        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>

